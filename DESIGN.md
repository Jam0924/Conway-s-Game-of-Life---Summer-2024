Title: Conway’s Game of Life
Implemented and Designed by: James Marciano

LANGUAGES USED:

Python
Javascript
HTML
CSS

GENERAL DESIGN:

My program is generally designed as a series of AJAX requests to transfer data between my back-end program which is Python and my front-end program which is JavaScript.

INTRODUCTION:

To start off my project Conway’s Game of Life I needed to create a grid of buttons that would fill the users screen, and have these buttons change between black and white when clicked. However, the first problem that I encountered was figuring the minimum amount of button columns and rows to fill a user’s screen with varying screen sizes.

HOME PAGE:

In order to tackle the issue of figuring out how many rows and columns of cells would be best to fit a screen, I decided to start developing a homepage first. In this homepage I made a title in the middle of the screen along with a button in the middle called “Play” that would use javascript to transfer the user over to the /game page. While the button looked to be a regular button, it was actually a form that was submitting two hidden values for device height and device width when the Play button was pressed. However, the basic HTML code would be unable to access this data, so I decided to implement a Javascript function that would operate upon the loading of the page that would set the value of these two hidden inputs to be the device width and the device height. In order to access these values, I began to implement the back-end part of my code. I created a file called app.py and used Flask to create an instance of the flask class. I then used flask-session to create a non-permanent session where I would store user’s data to use inside of the program. I created a route for the homepage of the program and then requested the form data. After requesting the form data I was able to save it in session variables that I could use globally across all routes.

MAKING THE GRID:

Now that I had the device width, I created more session instance variables using the device height and width to see the minimum number of rows and columns that were needed for that user’s device. Since each cell was a 30px cell, generally the amount of columns was the device height divided by 30 using integer division. Then, I made another session variable called board which was a 2 dimensional array of boolean values, all originally evaluated to be false due to all of the cells being dead at the start of the game. After this, I created a route for the game page and used the GET method to render the template with some Jinja variables called rows and columns. This would allow me to iterate over HTML code and create a 2d grid of buttons across the screen. I decided that I would use <div> elements with CSS classes to design them in order to create the button grid. Each row would have its own div element, and inside of each div element I would iterate and create a certain number of buttons depending on the value of columns. Then, I made each button have its ID to be formatted to have the current row value and the current column value separated by commas. This allowed each of my buttons to have its place on the grid represented by its ID, making identification easier. However, despite this the buttons still were nonfunctional and did not update any values or change color.

IMPLEMENTING THE BUTTONS:

Now that I was able to determine the button's location based on its ID and have the perfect amount of buttons for each user, I needed to figure out a way to make the button change color, and update its corresponding array value. In order to do this, I created a new route called update that only accepted post methods, and I created a Javascript function called update that accepted a button’s ID as its parameter. First, I used .getElementByID to get the element and then determine its current background color. If the current background color was black I switched it to white, and if it was white I switched it to black. After this, I made an AJAX request to my Python update route using a POST method. In order to start keeping track of how many cells were alive and dead, I created three more session values called alive, dead, and generation. Alive would keep track of how many cells were currently alive, dead would keep track of the total deaths for when I implemented logic later, and generation would keep track of what generation it is for when I implemented logic later on. In order to also update these new session values, my AJAX request sent the button’s ID in its data along with the color prior to the color change. In my python route I first split the button’s id to its individual row and column pieces, and then used the not keyword to update the boolean at the position [row][column] in the array to be the opposite of itself. Therefore, if the button was originally True (meaning the cell was alive), then it would turn False and vice versa. Then, if the button’s color before the change was white then I decremented the alive counter by one, as the cell was being killed by the user, and if the button’s  color was black I increased the counter by one since it meant a cell was coming to life. With this extra route and this extra function my user was able to place down cells onto the grid and have the corresponding counters and board to update based on the grid.

IMPLEMENTING LOGIC - BACK END:

Now that the array was accurately updated with the information, I was finally able to implement the core rules that Conway’s Game of Life provided. Since I wanted my version of Conway’s Game of Life to be more customizable, I decided to create 3 more session values to keep track of what the current minimum cells to survive was, the maximum cells before death, and the number of cells that were needed for reproduction. Although I set these values to the normal rules temporarily, later on I would implement a settings feature that could change all of these rules. To start implementing logic I first created a nested for loop that looped through every item in the two dimensional array. Then, for each object in the two dimensional array I used more nested for loops to loop in the 8 adjacent cells next to it. I skipped cells that were out of bounds of the array or that were the same as the current cell being observed by the outer for loops. Then, I started to keep track of how many cells adjacent to the focused cell were alive. With this value, I began to make a statement for each of the rules in Conway's game of life. First I determined if the targeted cell was alive. If the cell was alive, I determined if it was between the minimum number for survival and the maximum number before death. If it was, I inserted True into a new grid of the same size at that location to signify that the cell was alive, and then I moved on to the next targeted cell. However, if it wasn’t in this range I replaced the value with False and incremented the death counter to signify that a cell had died. If the cell that was targeted was dead I checked to see if the number of adjacent cells matched the number needed for repopulation. If it did, I inserted True for its value in the new grid and incremented the Alive counter by one since a cell had come to life. At the end of this process and going through all of the grid’s cells, I incremented the generation by one and set the session board to equal the new board that had been made. This allowed me to create a way for the array to move on to the next generation. I put all of this inside of a step route inside of my python code, and returned a jsonfield version of the board and the statistic counter to update the HTML code.



IMPLEMENTING LOGIC - FRONT END

Now that I had an array that would be updated between generations and returned a jsonified route, I created a new Javascript function that used AJAX to call the route and get the array. Then, I looped through this 2 dimensional array on the Javascript side, but instead of looping through the boolean values, I used for loops to get integer values and loop through indexes instead. This allowed me to access the buttons at that index, since the button format was row,column using array indices. Then, for each index in the array I checked if its value was True, if it was I updated the button with the corresponding ID to be white, and if it was False I updated the button with the corresponding ID to be black. This allowed me to have the visuals update between generations as well. Between steps I also created a div called stats, which would display the generation count, total deaths, and amount alive on the bottom of the screen for the user to see. I updated this along with the visuals and had made the basic version of Conway’s Game of Life.

IMPLEMENTING TOOLS:

From here, I decided to implement a couple of tools that would make it easier for the user to use my program. The first one I made was a Javascript function called Run that would repeatedly call the Step function across an interval. I also added a function called Pause that would stop this interval whenever it was still active, so that the user would be able to stop the program. I then decided to create another route in Python called previous_grid that would save the grid before it was run. This grid was saved to a session value called previous grid, and I slightly modified the run function to save the current grid before going to the next generation using step. On the Python side saving the grid was just a matter of storing the current board’s value inside of a session value called recent grid. Then there was another route which was to load it, that returned a jsonified version of the board to be looped over. In order to access this previous grid, I created a Javascript function called Previous that made an AJAX call to the load_previous_grid route that would get the recent grid. It also updated the current array board to match the previous grid, to make sure the array was still up to date. Then, I used the same code as I did in step to update the visuals of the grid. The last tool I implemented was a reset tool, which allowed me to fully reset the grid. It reset all the statistics, and all of the cells to be dead. These tools allowed testing to become much easier. I implemented this by using a Javascript function called Clear that made an AJAX call to a route named clear. The clear route made the grid completely blank, and reset all of the statistics. However, I decided to make generation start at -1 and instead of manually writing the code to display the grid again, I would just use the Step function already created on an empty grid to display the new grid. Since inserting an empty grid into the step function would return an empty grid, it was much more efficient then manually updating all of the buttons again. However, since the step increases the generation counter by 1, in order to have it start at 0 I had to initialize it to start at -1. This allowed me to create the last clear tool. I made icons for all of these tools and used CSS to create a task bar at the top of the screen that took up 5% of the view height. This caused me to shift all of the button rows down 5% of the screen so that the taskbar won't cover cells. Inside of this task bar I created a home icon that would take you back to the home page, along with icons for all of the tools. These icons were images, and then I used Javascript to add event listeners to all of the images and call their corresponding functions when they were clicked. I also added in the top right corner a gear icon that would move to the settings page.

SETTINGS:

The last thing I implemented was a setting page. This settings page would make the game truly customizable and unique compared to regular Conway’s Game of Life. First I created an HTML page that had a form with six text input boxes. The first two input boxes would be for the rows and columns of the grid. The third box would be for timing which would control the time between generations. The fourth box would be for the minimum cells needed for survival, the fifth was for the maximum before death, and the last cell was the number needed for reproduction. I also created a save button at the bottom of the form that would submit all of these values to a new route in the Python code for error checking. I first created the last session value for timing, which would control the timing between generations. I defaulted it to be at 300ms, and sent a new jinja variable into game.html so that the setInterval function that RUN used could use the timing variable that the user set. I also made a route for settings that can accept POST and GET methods. The GET method was so that I could input jinja variables in render_template that allowed all of the settings to already be filled out with their current values, usually the default values. The POST method was for when the user submits the form. When all of the data first reaches the settings route, my algorithm performs error checking and makes sure that all inputs are valid. For the rows and columns it makes sure that they are integers, and above their respective minimum values. For the timing it makes sure it is a float value above 0.1. For the timing, users input their value in seconds where I convert it into milliseconds inside of my code. For the last three inputs I make sure they are all valid integers between 1-8 inclusive, and make sure that the minimum cell value is not greater than the maximum. If there are inputs that do not match these rules my program will flash errors for the user to see, and force them to re-input values that are correct or keep the default values. If they are all proper values, I update all of the session values and display them back to the user. Then, the user can either click one of two buttons on the bottom of the screen. The return to game button which will bring the user to the game screen with their modified settings, or the reset to defaults which will reset all of the settings to default. Since my step function already used session values to update the grid, this implementation did not affect the run function. This settings option is what allowed me to implement new features, and complete my customizable Conway's Game of Life.
